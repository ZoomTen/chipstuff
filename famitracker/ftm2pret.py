#!/usr/bin/python

'''
Tool to convert *.ftm files to pret-compatible music files
'''

from ftmlib import FamitrackerModule
import datetime, sys

if __name__ == '__main__':
	fami = FamitrackerModule()
	fami.load_from_file(sys.argv[1])

	# single song for now
	song = fami.module['songs'][0]

	# -- setup --
	
	to_gb_env = lambda x: -7+((x & 0xf0) >> 4)-1 if (x & 0xf0) > 0 else 7-x+1
	nameify = lambda x: x.title().replace(' ', '')
	constify = lambda x: x.upper().replace(' ', '_')
	bpmify = lambda speed, tempo: 6 * tempo / speed
	to_tempo = lambda tempo: 19296 / tempo

	channel_bins = [
		{"frames":[], "patterns":[]},
		{"frames":[], "patterns":[]},
		{"frames":[], "patterns":[]},
		{"frames":[], "patterns":[]}
	]

	# move frames to channel bin
	for frame in song['frames']:
		for i in range(4):
			channel_bins[i]["frames"].append(frame[i])

	# move patterns to channel bin
	for pattern in song['patterns']:
		if pattern.channel < 4:
			channel_bins[pattern.channel]['patterns'].append(pattern)
	
	# -- function to render individual row --
	
	def render_row(prev_row, next_row, state):
		# process effects here
		note_duty = None
		note_envelope = None
		
		for effect in prev_row['effects']:
			if effect[0] == 18:
				# duty cycle
				note_duty = effect[1]
			if effect[0] == 22:
				# volume envelope
				note_envelope = effect[1]
		
		# change duty (Vxx)
		if note_duty is not None:
			if state['prev_duty'] != note_duty:
				state['prev_duty'] = note_duty
				print(f'\tduty_cycle {note_duty}')
		
		# change volume (volume column)
		note_volume = prev_row['volume']
		if state['prev_volume'] != note_volume:
			if note_volume is not None:
				# map volumes for ch3
				if state['channel'] == 2:
					if note_volume == 0:
						state['prev_volume'] = 0
					elif 0 < note_volume < 4:
						note_volume = 3
						state['prev_volume'] = note_volume
					elif 4 < note_volume < 8:
						note_volume = 2
						state['prev_volume'] = note_volume
					elif 8 < note_volume < 12:
						note_volume = 1
						state['prev_volume'] = note_volume
					elif 12 < note_volume < 16:
						note_volume = 0
						state['prev_volume'] = note_volume
				else:
					state['prev_volume'] = note_volume
				state['volume_changed'] = True
		
		# change envelope (Axx)
		if note_envelope is not None:
			if state['prev_envelope'] != note_envelope:
				state['prev_envelope'] = note_envelope
				state['envelope_changed'] = True
		
		if state['volume_changed'] or state['envelope_changed']:
			try:
				if state['channel'] < 2:
					print(f'\tnote_type 12, {state["prev_volume"]}, {to_gb_env(state["prev_envelope"])}')
				elif state['channel'] == 2:
					# don't remap Axx effects for triangle channel
					print(f'\tnote_type 12, {state["prev_volume"]}, {state["prev_envelope"]}')
			except:
				pass
		
		note_instrument = prev_row['instrument']

		# process notes and rests
		note_rendered = False
		
		# change octave
		note_octave = prev_row['octave']
		if state['prev_octave'] != note_octave:
			if note_octave is not None:
				if state['channel'] < 3:
					print(f'\toctave {note_octave}')
				state['prev_octave'] = note_octave
		
		# determine length
		note_length = next_row['position'] - prev_row['position']
		
		# render note
		note = prev_row['note']
		if note_length > 16:
			# split extremely long notes
			tmp_counter = note_length
			while tmp_counter - 16 > 0:
				if (note == '--') or (note is None):
					print(f'\trest 16')
				else:
					if state['channel'] == 3:
						print(f'\tdrum_note {constify(state["song_title"])}_DRUM_{note_instrument}, 16')
					else:
						print(f'\tnote {note}, 16')
				tmp_counter = tmp_counter - 16
			
			# note or rest
			if (note == '--') or (note is None):
				print(f'\trest {tmp_counter}')
			else:
				if note:
					if state['channel'] == 3:
						print(f'\tdrum_note {constify(state["song_title"])}_DRUM_{note_instrument}, {tmp_counter}')
					else:
						print(f'\tnote {note}, {tmp_counter}')
		else:
			# note or rest
			if (note == '--') or (note is None):
				print(f'\trest {note_length}')
			else:
				if note:
					if state['channel'] == 3:
						print(f'\tdrum_note {constify(state["song_title"])}_DRUM_{note_instrument}, {note_length}')
					else:
						print(f'\tnote {note}, {note_length}')
					state["cur_note"] = note
					note_rendered = True
				# retrigger note in case of volume or effects column
				if not note_rendered:
					if prev_row['volume'] or (len(prev_row['effects']) > 0):
						if state['channel'] == 3:
							print(f'\tdrum_note {constify(state["song_title"])}_DRUM_{note_instrument}, {note_length}')
						else:
							print(f'\tnote {state["cur_note"]}, {note_length}')

	# -- render pret asm --

	# render header
	print(f'''
	; ------------------------
	; Generated by ftm2pret.py
	;
	; from: {fami.file_name}
	; on:   {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
	; ------------------------
	''')
	for i in range(len(channel_bins)):
		channel = channel_bins[i]
		
		# add label
		print(f'\n{nameify(song["name"])}_Ch{i+1}:')
		
		# add basic song config
		if i == 0:
			print(f'\ttempo {int(to_tempo(bpmify(song["speed"], song["tempo"])))}')
		elif i == 3:
			print(f'\ttoggle_noise 0 ; delete this line if on pokered/pokeyellow')
			print(f'\tdrum_speed 12')
		
		# add frames
		for frame in channel['frames']:
			frame_found = False
			# cringe
			for pattern in channel['patterns']:
				if pattern.channel == i:
					if pattern.index == frame:
						frame_found = True
			if frame_found:
				print(f'\tsound_call .pattern_{frame}')
		print('\tsound_ret')
		
		# create patterns
		for pattern in channel['patterns']:
			print(f'.pattern_{pattern.index}')
			state = {
				"song_title": song["name"],
				"channel": i,
				"prev_row": None,
				"prev_octave": None,
				"prev_duty": 0,
				"prev_volume": 12,
				"prev_envelope": 0x08,
				"volume_changed": False,
				"envelope_changed": False,
				"cur_note": None
			}
			prev_row = None
			
			#if i < 3:
				# XXX: note_type doublings!!
				#print(f'\tnote_type 12, {state["prev_volume"]}, {to_gb_env(state["prev_envelope"])} ; fallback')
			
			# -- render out individual rows --
			for rn_ in range(len(pattern.content)):
				state["volume_changed"] = False
				state["envelope_changed"] = False
				
				if rn_ == len(pattern.content)-1:
					# Row number (n - 1)
					this_row = pattern.content[rn_]
					if prev_row is not None:
						render_row(prev_row, this_row, state)
					
					# Row number (n)
					fake_row_struct = {
						"position": song['rows'],
						"note": this_row['note'],
						"octave": None,
						"instrument": None,
						"volume": None,
						"effects": []
					}
					render_row(this_row, fake_row_struct, state)
				else:
					this_row = pattern.content[rn_]
					row_pos = this_row['position']
					if rn_ == 0:
						if row_pos > 0:
							rest_length = row_pos
							if rest_length > 16:
								tmp_counter = rest_length
								while tmp_counter - 16 > 0:
									print(f'\trest 16')
									tmp_counter = tmp_counter - 16
								print(f'\trest {tmp_counter}')
							else:
								print(f'\trest {rest_length}')
					if prev_row is not None:
						render_row(prev_row, this_row, state)
					prev_row = this_row
			print('\tsound_ret')
